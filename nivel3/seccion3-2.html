

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Instrucciones repetidas &#8212; Introducción a la Programación</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="canonical" href="http://cupi2-ip.github.io/IPBook/nivel3/seccion3-2.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">


<!-- Opengraph tags -->
<meta property="og:url"         content="http://cupi2-ip.github.io/IPBook/nivel3/seccion3-2.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Instrucciones repetidas" />
<meta property="og:description" content="Instrucciones repetidas  Objetivo de la sección  El objetivo de esta sección es introducir las instrucciones repetitivas utilizando la estructura while. Esto lo" />
<meta property="og:image"       content="http://cupi2-ip.github.io/IPBook/_static/uniandes_logo.jpeg" />

<meta name="twitter:card" content="summary" />


  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/uniandes_logo.jpeg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Introducción a la Programación</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../portada.html">
   Portada
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Contenido
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../introduccion/index.html">
   1. Nivel 0 - Antes de empezar
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../nivel1/intro.html">
   2. Nivel 1 - Empezando a programar
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../nivel2/intro.html">
   3. Nivel 2 - Tomando decisiones
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   4. Nivel 3 - Repitiendo acciones
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../nivel4/intro.html">
   5. Nivel 4 - Matrices y Librerías
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/nivel3/seccion3-2.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> On this page
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#repetir-instrucciones-usando-while">
   Repetir instrucciones usando while
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#elementos-de-un-while">
     Elementos de un while
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#inicializacion">
       Inicialización
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#condicion-del-ciclo">
       Condición del ciclo
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cuerpo-del-ciclo">
       Cuerpo del ciclo
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#avance">
       Avance
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#problema-con-el-avance">
       Problema con el avance
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#soluciones-alternativas-al-problema-del-factorial">
       Soluciones alternativas al problema del factorial
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#un-poco-de-algoritmica">
   Un poco de algorítmica
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#leer-y-entender-el-problema">
     Leer y entender el problema
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#plantear-una-estrategia-de-solucion-para-cada-parte-de-la-solucion-global">
     Plantear una
     <em>
      estrategia de solución
     </em>
     para cada parte de la solución global
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#construir-la-solucion-para-cada-parte-de-la-solucion-global">
     Construir la solución para cada parte de la solución global
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sumatorias-y-series">
   Sumatorias y series
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#el-truco-del-centinela">
   El truco del centinela
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#calculo-del-seno-de-un-angulo">
     Cálculo del seno de un ángulo
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#for-in-range">
   For-in-range
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ciclos-e-interfaces-basadas-en-consola">
   Ciclos e interfaces basadas en consola
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ejercicios">
   Ejercicios
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mas-alla-de-python">
   Más allá de Python
  </a>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="warning admonition">
<p class="admonition-title">Versión borrador / preliminar</p>
<p>Este documento es una versión preliminar para uso interno. Si encuentra algún problema o error, o si tiene algún comentario por favor repórtelo a los autores.</p>
</div>
<div class="section" id="instrucciones-repetidas">
<h1>Instrucciones repetidas<a class="headerlink" href="#instrucciones-repetidas" title="Permalink to this headline">¶</a></h1>
<div class="admonition-objetivo-de-la-seccion admonition">
<p class="admonition-title">Objetivo de la sección</p>
<p>El objetivo de esta sección es introducir las instrucciones repetitivas utilizando la estructura <code class="docutils literal notranslate"><span class="pre">while</span></code>. Esto lo usaremos para ciclos donde se conoce con anterioridad la cantidad de iteraciones y también para ciclos donde sea necesario reconocer una condición de parada.</p>
</div>
<p>Hasta el momento los programas que hemos construido ejecutan cada instrucción una única vez, a menos que se encuentren dentro de funciones que se llamen varias veces. El problema es que desde que se escriba el programa también va a quedar establecida la cantidad de veces que se llame cada función.</p>
<p>Tomemos por ejemplo el caso del juego de 21 (BlackJack) que estudiamos en el nivel anterior. Tal como está construido, el jugador y la casa tienen como máximo 5 turnos para jugar y sería necesario modificar el código fuente del programa para que pudieran tener más turnos. En particular, para que tuvieran una sexta carta tendríamos que agregar las siguientes instruciones a la función <code class="docutils literal notranslate"><span class="pre">iniciar_aplicacion</span></code> de la consola:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="n">continuar_juego</span><span class="p">:</span>
        <span class="n">continuar_juego</span> <span class="o">=</span> <span class="n">turno_jugador</span><span class="p">(</span><span class="n">mano_jugador</span><span class="p">,</span> <span class="n">mano_casa</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="n">continuar_juego</span><span class="p">:</span>
        <span class="n">continuar_juego</span> <span class="o">=</span> <span class="n">turno_casa</span><span class="p">(</span><span class="n">puntos_jugador</span><span class="p">,</span> <span class="n">mano_casa</span><span class="p">)</span>
</pre></div>
</div>
<p>Esto puede solucionarse a través del uso de instrucciones iterativas, las cuales nos permiten expresar cuántas veces tiene que ejecutarse una instrucción sin tener que escribirla muchas veces. Más aún, la cantidad no tendría que estar definida <em>a priori</em> sino que se le podría preguntar al usuario o podría depender de una condición que se revise dentro del programa.</p>
<p>En esta sección vamos a introducir el concepto de instrucciones iterativas y vamos a explicar cómo se implementan en Python usando la instrucción <code class="docutils literal notranslate"><span class="pre">while</span></code>. Esto lo vamos a ilustrar con varios ejemplos y, en particular, vamos a mostrar su aplicación en matemáticas para el cálculo de series y sumatorias. Al final de la sección introduciremos también la instrucción <code class="docutils literal notranslate"><span class="pre">for</span></code> de Python, aunque su uso completo lo desarrollaremos en una sección posterior.</p>
<div class="section" id="repetir-instrucciones-usando-while">
<h2>Repetir instrucciones usando while<a class="headerlink" href="#repetir-instrucciones-usando-while" title="Permalink to this headline">¶</a></h2>
<p>En Python, así como en muchos otros lenguajes, la base de las instrucciones iterativas es una expresión como la siguiente: <em>“mientras que X sea cierto, haga Y”</em>. En inglés, esto se traduciría como <em>“while X, do Y”</em>. Por esto, la instrucción fundamental para expresar iteraciones en Python y en muchos lenguajes se llama <code class="docutils literal notranslate"><span class="pre">while</span></code>.</p>
<p>Así como un <code class="docutils literal notranslate"><span class="pre">if</span></code> define una estructura en la cual se tiene que tener como mínimo una condición y un cuerpo, en el caso del <code class="docutils literal notranslate"><span class="pre">while</span></code> ocurre algo similar: se requiere una condición (la X en la expresión anterior) y un cuerpo (la Y). La principal diferencia con un <code class="docutils literal notranslate"><span class="pre">if</span></code> es que la condición se va a evaluar muchas veces y que el cuerpo se va a ejecutar cada vez que la condición sea verdadera. Observemos esto en un ejemplo:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">contador</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">while</span> <span class="n">contador</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">contador</span><span class="p">)</span>
  <span class="n">contador</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;¡Despegue!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Lo primero que encontramos en este código es que vamos a crear una nueva variable llamada <code class="docutils literal notranslate"><span class="pre">contador</span></code> y la vamos a inicializar en <code class="docutils literal notranslate"><span class="pre">5</span></code>. A continuación inicia un bloque <code class="docutils literal notranslate"><span class="pre">while</span></code>, donde la condición es <code class="docutils literal notranslate"><span class="pre">contador</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. Esto quiere decir que el cuerpo del <code class="docutils literal notranslate"><span class="pre">while</span></code> (todo lo que está indentado después de <code class="docutils literal notranslate"><span class="pre">:</span></code>) se va a ejecutar varias veces, hasta que la condición deje de ser verdadera. Esta condición se evaluará antes de la primera vez que se ejecute el cuerpo y se volverá a evaluar después de cada ejecución del cuerpo. El cuerpo de este <code class="docutils literal notranslate"><span class="pre">while</span></code> tiene sólo dos instrucciones: la primer imprime en la consola el valor actual de la variable <code class="docutils literal notranslate"><span class="pre">contador</span></code> mientras que la segunda reduce el valor de <code class="docutils literal notranslate"><span class="pre">contador</span></code> en uno. La última instrucción del ejemplo imprime la cadena <code class="docutils literal notranslate"><span class="pre">'¡Despegue!'</span></code> en la consola.</p>
<p>La siguiente imagen muestra lo que ocurriría durante las primeras iteraciones del ciclo. Al iniciar, la consola estaría vacía y se crearía sólo la variable <code class="docutils literal notranslate"><span class="pre">contador</span></code> con valor 5. Al iniciar el ciclo lo primero que se hace es evaluar la condición y, como es verdadera, se ejecuta el cuerpo del ciclo. Esto imprime en la consola el valor del contador en ese momento (<code class="docutils literal notranslate"><span class="pre">5</span></code>) y luego decremental contador, dejando su valor en <code class="docutils literal notranslate"><span class="pre">4</span></code>. En este punto se vuelve a evaluar la condición y como sigue siendo cierta se ejecuta nuevamente el cuerpo del ciclo.</p>
<p><img alt="Primeras iteraciones" src="../_images/liftoff1.png" /></p>
<p>Veamos ahora lo que ocurre en las iteraciones finales, cuando el contador haya alcanzado el valor 1 y se hayan mostrado en la consola los números entre 5 y 2. Al evaluar la condición el resultado seguirá siendo verdadero, así que el cuerpo se ejecutará nuevamente: se imprime el número 1 en la consola y se decrementa el valor de <code class="docutils literal notranslate"><span class="pre">contador</span></code>. A continuación se evalua la condición pero esta vez resulta falsa porque ahora <code class="docutils literal notranslate"><span class="pre">contador</span></code> no tiene un valor mayor a 0. Esto hace que se termine la ejecución del ciclo y se ejecuten las instrucciones siguientes. En este caso, esto significa mostrar en la consola la cadena <code class="docutils literal notranslate"><span class="pre">'¡Despegue!</span></code>.</p>
<p><img alt="Iteraciones finales" src="../_images/liftoff2.png" /></p>
<p>Algo muy interesante para notar en el ejemplo anterior, y que se puede ver en la figura, es que el valor de la variable <code class="docutils literal notranslate"><span class="pre">contador</span></code> se mantiene al terminar el ciclo. Es decir que sigue siendo <code class="docutils literal notranslate"><span class="pre">0</span></code> y no vuelve al valor que tenía antes de que se ejecutara el ciclo.</p>
<div class="section" id="elementos-de-un-while">
<h3>Elementos de un while<a class="headerlink" href="#elementos-de-un-while" title="Permalink to this headline">¶</a></h3>
<p>Acabamos de mostrar con un ejemplo cómo es la ejecución de un <code class="docutils literal notranslate"><span class="pre">while</span></code>. Ahora estudiaremos con un poco más de cuidado los diferentes elementos que se tienen que considerar cuando se construya una instrucción iterativa. Para esto usaremos la siguiente función que sirve para calcular el factorial de un número recordando que:</p>
<p>\begin{equation}
n! = 1 · 2 · \dots (n-2) · (n-1) · n
\end{equation}</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
  <span class="n">resultado</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">numero_actual</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">while</span> <span class="n">numero_actual</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
    <span class="n">resultado</span> <span class="o">=</span> <span class="n">resultado</span> <span class="o">*</span> <span class="n">numero_actual</span>
    <span class="n">numero_actual</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">resultado</span>
</pre></div>
</div>
<p>Esta función calcula el factorial del número <code class="docutils literal notranslate"><span class="pre">n</span></code> multiplicando entre ellos todos los números anteriores. El punto importante es que esto lo vamos a hacer número por número, partiendo desde el número 1 y llegando hasta el número <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>Estudiemos ahora en detalle cada elemento de la función.</p>
<div class="section" id="inicializacion">
<h4>Inicialización<a class="headerlink" href="#inicializacion" title="Permalink to this headline">¶</a></h4>
<p>Aunque no es parte explícita de un <code class="docutils literal notranslate"><span class="pre">while</span></code>, las instrucciones que se encuentran antes son importantísimas porque realizan la <em>inicialización</em> del ciclo. Es decir, dejan las variables que nos interesen en el estado necesario para que se pueda ejecutar el ciclo y se obtenga el resultado esperado.</p>
<p>En el caso de nuestra función, hay dos instrucciones que sirven para inicializar el ciclo:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>  <span class="n">resultado</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">numero_actual</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>La primera instrucción sirve para crear una variable donde dejaremos el resultado de nuestra función. En este caso, ese resultado será el factorial del parámetro <code class="docutils literal notranslate"><span class="pre">n</span></code>. La variable <code class="docutils literal notranslate"><span class="pre">resultado</span></code> la hemos inicializado en 1 por varios motivos que discutiremos más adelante.</p>
<p>La segunda instrucción sirve para crear una variable que nos permitirá saber cuál es el siguiente número que tenemos que multiplicar para seguir calculando el factorial. En este caso, la variable <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code> la inicializamos en 2 porque el resultado ya estaba inicializado en 1. Si la variable la hubiéramos inicializado en 1 no habría cambiado nuestro programa, pero habría hecho una iteración más en el que habría multiplicado <code class="docutils literal notranslate"><span class="pre">1*1</span></code>.</p>
</div>
<div class="section" id="condicion-del-ciclo">
<h4>Condición del ciclo<a class="headerlink" href="#condicion-del-ciclo" title="Permalink to this headline">¶</a></h4>
<p>La siguiente parte del análisis de nuestra función se concentra en la condición del <code class="docutils literal notranslate"><span class="pre">while</span></code>. Debemos recordar que cuando la condición de un <code class="docutils literal notranslate"><span class="pre">while</span></code> sea verdadera, el cuerpo del ciclo deberá ejecutarse. Si lo vemos desde el punto de vista opuesto, el cuerpo del ciclo tendrá que ejecutarse hasta que la condición sea falsa.</p>
<p>Las dos perspectivas son equivalentes pero, dependiendo del problema, es posible que una de las dos perspectiva sea más fácil de entender. La recomendación que podemos hacer es utilizar nombres de variables que sean muy claros, de tal forma que la condición sea fácil de <em>leer</em>. Por ejemplo, en el caso de nuestra función, la condición puede <em>leerse</em> fácilmente como “Mientras que el número actual sea menor o igual que n, se debe hacer …”.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>  <span class="k">while</span> <span class="n">numero_actual</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
</pre></div>
</div>
<p>La misma condición también se podría haber escrito de la siguiente forma, en la cual la lectura natural sería “Mientras que el número actual no sea mayor a n, se debe hacer …”.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>  <span class="k">while</span> <span class="ow">not</span> <span class="n">numero_actual</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
</pre></div>
</div>
</div>
<div class="section" id="cuerpo-del-ciclo">
<h4>Cuerpo del ciclo<a class="headerlink" href="#cuerpo-del-ciclo" title="Permalink to this headline">¶</a></h4>
<p>Después de evaluada la condición de un <code class="docutils literal notranslate"><span class="pre">while</span></code>, se ejecuta una o varias veces el <em>cuerpo del ciclo</em>. El caso de nuestra función, el cuerpo tiene dos instrucciones:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">resultado</span> <span class="o">=</span> <span class="n">resultado</span> <span class="o">*</span> <span class="n">numero_actual</span>
    <span class="n">numero_actual</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>La primera instrucción es la que se encarga de ir acumulando en la variable <code class="docutils literal notranslate"><span class="pre">resultado</span></code> el valor del factorial del número. Para esto, la instrucción toma el valor que se había acumulado hasta el momento, lo multiplica por el número actual y vuelve a guardarlo en <code class="docutils literal notranslate"><span class="pre">resultado</span></code>. La segunda instrucción se encarga de ir incrementando de uno en uno el valor de <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code>.</p>
<p>La siguiente tabla muestra cómo va cambiando el valor de <code class="docutils literal notranslate"><span class="pre">resultado</span></code> y de <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code> a medida que se ejecuta el ciclo:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p><code class="docutils literal notranslate"><span class="pre">resultado</span></code></p></th>
<th class="text-align:center head"><p><code class="docutils literal notranslate"><span class="pre">numero_actual</span></code></p></th>
<th class="text-align:right head"><p>Valor calculado en <code class="docutils literal notranslate"><span class="pre">resultado</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>2</p></td>
<td class="text-align:right"><p>1!</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>2</p></td>
<td class="text-align:center"><p>3</p></td>
<td class="text-align:right"><p>2!</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>6</p></td>
<td class="text-align:center"><p>4</p></td>
<td class="text-align:right"><p>3!</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>24</p></td>
<td class="text-align:center"><p>5</p></td>
<td class="text-align:right"><p>4!</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>120</p></td>
<td class="text-align:center"><p>6</p></td>
<td class="text-align:right"><p>5!</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>720</p></td>
<td class="text-align:center"><p>7</p></td>
<td class="text-align:right"><p>6!</p></td>
</tr>
</tbody>
</table>
<p>Antes de la primera ejecución, el valor de <code class="docutils literal notranslate"><span class="pre">resultado</span></code> es 1 y el valor de <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code> es 2, como se determinó en la inicialización. Eso quiere decir que el valor de <code class="docutils literal notranslate"><span class="pre">resultado</span></code> es equivalente al valor de <code class="docutils literal notranslate"><span class="pre">1!</span></code> y que el siguiente número por el que debería multiplicarse es 2.</p>
<p>Después de la primera ejecución del ciclo, el valor de <code class="docutils literal notranslate"><span class="pre">resultado</span></code> se modifica para que sea 2, y el valor de <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code> se incrementa en uno. Esto quiere decir que ahora el valor de <code class="docutils literal notranslate"><span class="pre">resultado</span></code> es equivalente al valor de <code class="docutils literal notranslate"><span class="pre">2!</span></code>.</p>
<p>En la siguiente iteración el valor de <code class="docutils literal notranslate"><span class="pre">resultado</span></code> se multiplica por 3 y  y el valor de <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code> llega a 4. Como ahora el valor de <code class="docutils literal notranslate"><span class="pre">resultado</span></code> es 6, quiere decir que es equivalente a <code class="docutils literal notranslate"><span class="pre">3!</span></code>.</p>
<p>El proceso continua hasta que <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code> es mayor a <code class="docutils literal notranslate"><span class="pre">n</span></code>. Por ejemplo, si <code class="docutils literal notranslate"><span class="pre">n</span></code> fuera 6, entonces en la última iteración <code class="docutils literal notranslate"><span class="pre">resultado</span></code> se multiplicaría por 6 quedando con un valor equivalente al de <code class="docutils literal notranslate"><span class="pre">6!</span></code> y <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code> llegaría a 7. La siguiente vez que se revisara la condición ya no sería verdadera y el ciclo terminaría.</p>
</div>
<div class="section" id="avance">
<h4>Avance<a class="headerlink" href="#avance" title="Permalink to this headline">¶</a></h4>
<p>La segunda instrucción del cuerpo, <code class="docutils literal notranslate"><span class="pre">numero_actual</span> <span class="pre">+=</span> <span class="pre">1</span></code>, tiene el rol de <em>avanzar</em> el ciclo hacia su terminación. Este rol es muy importante dentro de cualquier ciclo: siempre tiene que haber una o varias instrucciones que hagan que con cada iteración el ciclo esté más cerca de terminar. Si no se cumpliera esto, el ciclo nunca terminaría.</p>
<p>En nuestra función para el cálculo del factorial, con cada iteración aumentamos en uno el valor de <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code>, con lo cual nos aseguramos que eventualmente este número sea mayor a <code class="docutils literal notranslate"><span class="pre">n</span></code> y el ciclo termine. En el caso del contador para el despegue, vamos reduciendo el valor de <code class="docutils literal notranslate"><span class="pre">contador</span></code> haciendo que eventualmente se vuelva falsa la condición del ciclo: <code class="docutils literal notranslate"><span class="pre">contador</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</div>
<div class="section" id="problema-con-el-avance">
<h4>Problema con el avance<a class="headerlink" href="#problema-con-el-avance" title="Permalink to this headline">¶</a></h4>
<p>En los dos ejemplos que hemos estudiado identificar el avance fue relativamente fácil. Más adelante en esta sección estudiaremos algunos programas donde no es tan fácil ver que el ciclo se está acerca acercando a la terminación. Por ahora veamos unos ejemplos de programas con problemas y que resultarán en ciclos infinitos.</p>
<p><strong>Alejarse de terminación</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Terminé&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Este primer programa nunca termina porque el valor de <code class="docutils literal notranslate"><span class="pre">i</span></code> siempre es mayor a 0.</p>
<p><strong>Brincarse la meta</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">:</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Terminé&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Este programa tampoco termina porque <code class="docutils literal notranslate"><span class="pre">i</span></code> siempre va a ser diferente que 10. El problema acá es que estamos incrementando <code class="docutils literal notranslate"><span class="pre">i</span></code> de dos en dos, pero empezando en 1. Esto quiere decir que <code class="docutils literal notranslate"><span class="pre">i</span></code> sólo va a asumir valores impares. Una forma fácil de solucionar este problema habría sido cambiar la condición para que fuera `i &lt; 10’.</p>
<p><strong>Problemas de indentación</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Terminé&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Aunque este programa tiene todas las instrucciones que se esperarían, tampoco terminará nunca su ejecución. El problema acá es que el avance no está dentro del ciclo: la variable <code class="docutils literal notranslate"><span class="pre">i</span></code> siempre va a tener el valor 1 porque el único lugar donde se cambia es inmediatamente después del ciclo.</p>
<p><strong>Olvidar el avance</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Terminé&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Aunque es muy sencillo, este programa ilustra el problema que se presenta más frecuentemente cuando se trabaja con ciclos: olvidar el avance. Como en este caso <code class="docutils literal notranslate"><span class="pre">i</span></code> nunca cambia de valor, el ciclo no se acerca a terminación a medida que se ejecuta.</p>
</div>
<div class="section" id="soluciones-alternativas-al-problema-del-factorial">
<h4>Soluciones alternativas al problema del factorial<a class="headerlink" href="#soluciones-alternativas-al-problema-del-factorial" title="Permalink to this headline">¶</a></h4>
<p>La solución al problema de calcular el factorial que presentamos es sólo una de muchas que se podrían haber planteado. A continuación presentamos otras soluciones que usted podría haberse imaginado. Nuestro objetivo es que usted vea que cualquier problema puede resolverse de varias maneras. Salvo la primera (empezar desde 1), ninguna de las soluciones que vamos a presentar es mejor o peor que otra: son equivalentes, son prácticamente igual de rápidas y cualquier persona debería ser capaz de entenderlas sin mucho esfuerzo.</p>
<p><strong>Empezar desde 1</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">factorial_v2</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
  <span class="n">resultado</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">numero_actual</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="n">numero_actual</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
    <span class="n">resultado</span> <span class="o">=</span> <span class="n">resultado</span> <span class="o">*</span> <span class="n">numero_actual</span>
    <span class="n">numero_actual</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">resultado</span>
</pre></div>
</div>
<p>Esta versión de la función tiene sólo una pequeña diferencia con respecto a la original: en lugar de inicializar <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code> en 2, se incializó en <code class="docutils literal notranslate"><span class="pre">1</span></code>. Esto hace que se tenga que hacer una iteración más al inicio, en la cual se hace la siguiente asignación (<code class="docutils literal notranslate"><span class="pre">resultado</span></code> tiene también valor <code class="docutils literal notranslate"><span class="pre">1</span></code> en ese momento):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>  <span class="n">resultado</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">1</span>
</pre></div>
</div>
<p><strong>De atrás para adelante</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">factorial_v3</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
  <span class="n">resultado</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">numero_actual</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
  <span class="k">while</span> <span class="n">numero_actual</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">resultado</span> <span class="o">=</span> <span class="n">resultado</span> <span class="o">*</span> <span class="n">numero_actual</span>
    <span class="n">numero_actual</span> <span class="o">-=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">resultado</span>
</pre></div>
</div>
<p>Esta nueva versión de la función se basa en la descomposición del factorial al contrario:</p>
<p>\begin{equation}
n! = n · (n-1) · (n-2) · \dots · 1
\end{equation}</p>
<p>De esta forma, para calcular el factorial de <code class="docutils literal notranslate"><span class="pre">n</span></code> se tiene que tomar el valor <code class="docutils literal notranslate"><span class="pre">n</span></code> y multiplicarlo por todos los valores menores a él. En nuestra función esto lo logramos inicializando <code class="docutils literal notranslate"><span class="pre">resultado</span></code> en <code class="docutils literal notranslate"><span class="pre">n</span></code> y <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code> en <code class="docutils literal notranslate"><span class="pre">n-1</span></code>, cambiando el avance para que vaya restándole 1 a <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code> y cambiando la condición para que el ciclo termine cuando <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code> sea 1.</p>
<p><strong>Restando</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">factorial_v4</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
  <span class="n">resultado</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">resta</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="n">resta</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
    <span class="n">resultado</span> <span class="o">=</span> <span class="n">resultado</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">resta</span><span class="p">)</span>
    <span class="n">resta</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">resultado</span>
</pre></div>
</div>
<p>En este caso nos basamos en la misma descomposición que en el caso anterior, pero ahora calculamos cada término como una resta. Es decir que a medida que avanzamos en el ciclo le vamos restando un número mayor a <code class="docutils literal notranslate"><span class="pre">n</span></code>, pero nunca guardamos ese resultado como lo hacíamos antes con <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code>.</p>
<p><strong>Cambio de límites</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">factorial_v5</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
  <span class="n">resultado</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">ultimo_numero</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="n">ultimo_numero</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
    <span class="n">resultado</span> <span class="o">=</span> <span class="n">resultado</span> <span class="o">*</span> <span class="p">(</span><span class="n">ultimo_numero</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ultimo_numero</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">resultado</span>
</pre></div>
</div>
<p>Esta última versión de la función cambia los límites dentro de los que se está trabajando: en lugar de que <code class="docutils literal notranslate"><span class="pre">numero_actual</span></code> vaya de 2 a <code class="docutils literal notranslate"><span class="pre">n</span></code>, en este caso <code class="docutils literal notranslate"><span class="pre">ultimo_numero</span></code> va de 1 a <code class="docutils literal notranslate"><span class="pre">n-1</span></code>. Esto implica un cambio en la condición del ciclo para que no use el operador <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> sino el operador ‘&lt;’.</p>
</div>
</div>
</div>
<div class="section" id="un-poco-de-algoritmica">
<h2>Un poco de algorítmica<a class="headerlink" href="#un-poco-de-algoritmica" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Always remember, however, that there’s usually a simpler and better way to do something than the first way that pops into your head.</p>
<p>Donald Knuth</p>
</div></blockquote>
<p>Lo que ya estudiamos en este capítulo nos sirvió para introducir el vocabulario fundamental de instrucciones iterativas y los principales elementos sintácticos de Python para soportar la construcción de ciclos. A continuación, vamos a empezar a discutir la parte metodológica de la construcción de ciclos. Es decir, la forma en la que se debe pensar la solución a un problema que requiere del uso de ciclos <a class="footnote-reference brackets" href="#introalgo" id="id1">1</a>.</p>
<p>La discusión la ilustraremos usando el siguiente problema:</p>
<blockquote>
<div><p>Dada una cadena de caracteres, usted debe calcular cuál es la vocal que más aparece en la cadena. Si hay vocales empatadas en la primera posición, la respuesta debería ser la vocal que vaya antes en el orden lexicográfico. La cadena puede tener letras mayúsculas y minúsculas, así como signos de puntuación, números y espacios.</p>
</div></blockquote>
<p>El plan que vamos a seguir, y que usted debería seguir siempre que se enfrente a un problema, es el siguiente:</p>
<ol class="simple">
<li><p>Leer y entender el problema</p></li>
<li><p>Plantear una estrategia global de solución</p></li>
<li><p>Plantear una <em>estrategia de solución</em> para cada parte de la solución global</p></li>
<li><p>Construir la solución para cada parte de la solución global</p></li>
<li><p>Construir la solución global a partir de las partes que ya construimos</p></li>
</ol>
<div class="section" id="leer-y-entender-el-problema">
<h3>Leer y entender el problema<a class="headerlink" href="#leer-y-entender-el-problema" title="Permalink to this headline">¶</a></h3>
<p>Es imposible resolver un problema que si no se ha entendido antes. Lea detenidamente el problema con el que vamos a trabajar y hágase las siguientes preguntas:</p>
<ol class="simple">
<li><p>¿Entendió el contexto general del problema?</p></li>
<li><p>¿Entendió lo que su programa tiene que hacer específicamente?</p></li>
<li><p>¿Entendió las reglas particulares que aplican para el problema?</p></li>
</ol>
<p>Verifique esto calculando manualmente qué debería responder el problema para cada una de las siguientes cadenas:</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'aaa'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'aeeiiiooouuuu'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'uoiea'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Uuuuyyyyyy!!!'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">¡Oe</span> <span class="pre">Oe</span> <span class="pre">Ooooeeeea!</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Esto</span> <span class="pre">no</span> <span class="pre">es</span> <span class="pre">ni</span> <span class="pre">una</span> <span class="pre">prueba</span> <span class="pre">ni</span> <span class="pre">un</span> <span class="pre">simulacro'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">''</span></code></p></li>
</ol>
<p>Escriba las respuestas para cada uno de los casos y compárelo con nuestras respuestas (ver nota con respuestas <a class="footnote-reference brackets" href="#respuestas" id="id2">2</a>). Si para alguna de las preguntas usted respondió algo diferente, revise nuevamente el enunciado hasta que entienda por qué su respuesta y la nuestra son diferentes.</p>
</div>
<div class="section" id="plantear-una-estrategia-de-solucion-para-cada-parte-de-la-solucion-global">
<h3>Plantear una <em>estrategia de solución</em> para cada parte de la solución global<a class="headerlink" href="#plantear-una-estrategia-de-solucion-para-cada-parte-de-la-solucion-global" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="construir-la-solucion-para-cada-parte-de-la-solucion-global">
<h3>Construir la solución para cada parte de la solución global<a class="headerlink" href="#construir-la-solucion-para-cada-parte-de-la-solucion-global" title="Permalink to this headline">¶</a></h3>
<p>###Construir la solución global a partir de las partes que ya construimos</p>
</div>
</div>
<div class="section" id="sumatorias-y-series">
<h2>Sumatorias y series<a class="headerlink" href="#sumatorias-y-series" title="Permalink to this headline">¶</a></h2>
<p>ejemplos de sumatorias</p>
<p>sum i de 1 a n = n(n+1)/2</p>
<p>Uso de ecuaciones dentro del markdown …</p>
<p>\begin{equation}
\int_0^\infty \frac{x^3}{e^x-1},dx = \frac{\pi^4}{15}
\end{equation}</p>
<p>\begin{equation}
\sum_{i=1}^n i = \frac{n(n+1)}{2}
\end{equation}</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sumar_numeros</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">sumatoria</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
    <span class="n">sumatoria</span> <span class="o">+=</span> <span class="n">i</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">sumatoria</span>
</pre></div>
</div>
<p>ejemplos de series</p>
<p>sum n: 1/2^n</p>
<p>\begin{equation}
\sum_{n=0}^\infty \frac{1}{2n}
\end{equation}</p>
<p>sum i: -1^(i+1) * 4 / 2i - 1  == PI</p>
<p>\begin{equation}
\sum_{i=1}^\infty \frac{-1^{i+1}*4}{2i-1} = \pi
\end{equation}</p>
</div>
<div class="section" id="el-truco-del-centinela">
<h2>El truco del centinela<a class="headerlink" href="#el-truco-del-centinela" title="Permalink to this headline">¶</a></h2>
<p>Motivación del centinela:
Buscar un número aleatorio (dados)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="n">numero_buscado</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">numero_intentos</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">encontre_numero</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">while</span> <span class="ow">not</span> <span class="n">encontre_numero</span><span class="p">:</span>
  <span class="n">numero_intentos</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">nuevo_numero</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nuevo_numero</span> <span class="o">==</span> <span class="n">numero_buscado</span><span class="p">:</span>
    <span class="n">encontre_numero</span> <span class="o">=</span> <span class="kc">True</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Encontré el número&quot;</span><span class="p">,</span> <span class="n">numero_buscado</span><span class="p">,</span> <span class="s2">&quot;después de&quot;</span><span class="p">,</span> <span class="n">numero_intentos</span><span class="p">,</span> <span class="s2">&quot;intentos&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Máximo común divisor</p>
<p>Buscar una vocal minúscula en una cadena</p>
<p>OJO: De Morgan!</p>
<p><a class="footnote-reference brackets" href="#demorgan" id="id3">3</a></p>
<div class="section" id="calculo-del-seno-de-un-angulo">
<h3>Cálculo del seno de un ángulo<a class="headerlink" href="#calculo-del-seno-de-un-angulo" title="Permalink to this headline">¶</a></h3>
<p>Una de las formas para calcular el seno de un ángulo es utilizar la siguiente serie, donde <code class="docutils literal notranslate"><span class="pre">x</span></code> es el ángulo en radianes.</p>
<p>\begin{equation}
\sum_{n=0}^\infty \frac{-1^n}{(2n+1)!} x^{2n+1} = \sin x
\end{equation}</p>
<p>Vamos a implementar una función que calcule el valor de la serie pero, como ya sabemos, no podemos construir un ciclo que realice un número infinito de operaciones. En la primera versión de nuestra función, vamos a utilizar un número fijo de iteraciones (<code class="docutils literal notranslate"><span class="pre">5</span></code>) y vamos a ver qué tan bien se comporta comparando el resultado que obtengamos con el que nos ofrece la función <code class="docutils literal notranslate"><span class="pre">math.sin</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">seno_v1</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot; Esta función calcula el seno del ángulo x utilizando los 5 primeros términos de la serie.</span>
<span class="sd">  Parámetros:</span>
<span class="sd">    x (float): El ángulo en radianes para el que se quiere calcular el seno.</span>
<span class="sd">  Retorno:</span>
<span class="sd">    (float): El seno del ángulo</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">iteraciones</span> <span class="o">=</span> <span class="mi">5</span>
  <span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">iteraciones</span><span class="p">:</span>
    <span class="n">signo</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">mult</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">suma</span> <span class="o">+=</span> <span class="p">(</span><span class="n">signo</span><span class="o">*</span><span class="n">mult</span><span class="o">/</span><span class="n">denom</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">suma</span>

<span class="k">def</span> <span class="nf">probar</span><span class="p">(</span><span class="n">angulo</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot; Invoca la función seno_v1 para calcular el seno del ángulo y compara el resultado</span>
<span class="sd">      con el resultado que arroja la función sin del módulo math.</span>
<span class="sd">  Parámetros:</span>
<span class="sd">    angulo (float): El ángulo en radianes con el que se va a hacer la prueba  </span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">seno_v1</span><span class="p">(</span><span class="n">angulo</span><span class="p">)</span>
  <span class="n">real</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angulo</span><span class="p">)</span>
  <span class="n">error</span> <span class="o">=</span> <span class="n">res</span> <span class="o">-</span> <span class="n">real</span>
  <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ángulo:&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">angulo</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;Calculado:&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;Real:&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;Error:&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="n">probar</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">probar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span>
<span class="n">probar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="n">probar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">probar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>Al ejecutar este programa obtenemos el siguiente resultado en la consola, que nos muestra que nuestra función es bastante precisa a pesar de utilizar sólo 5 iteraciones.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ángulo</span><span class="p">:</span> <span class="mi">0</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">0.0</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">0.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">0.0</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">0.52</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">0.5</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">0.5</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">0.0</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">1.05</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">0.87</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">0.87</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">0.0</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">1.57</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">1.0</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">1.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">0.0</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">3.14</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">0.01</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">0.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">0.0069</span>
</pre></div>
</div>
<p>Sin embargo, esta situación cambia bastante si aumentamos el tamaño del ángulo y realizamos pruebas como las siguientes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">probar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="n">probar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">probar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="n">probar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">probar</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>En este caso, los resultados en la consola nos muestran que nuestra función no funciona de forma muy buena a medida que los ángulos crecen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ángulo</span><span class="p">:</span> <span class="mf">4.71</span> <span class="n">Calculado</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.44</span> <span class="n">Real</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">0.5556</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">6.28</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">11.9</span> <span class="n">Real</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">11.8996</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">7.85</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">123.75</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">1.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">122.7476</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">9.42</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">795.87</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">0.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">795.8724</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">12.57</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">14008.9</span> <span class="n">Real</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">14008.902</span>
</pre></div>
</div>
<p>Una forma de solucionar este problema sería aumentar el número de iteraciones, pero más adelante el mismo problema volvería a presentarse. Una mejor alternativa, muy utilizada en cálculos como estos, es aplicar la estrategia del centinela. Para esto tenemos que notar que los términos de la serie son cada vez más pequeños porque (2n+1)! domina sobre x^(2n+1). Lo que podemos hacer es detener el ciclo cuando los nuevos términos de la serie no estén modificando significativamente el valor final. Esta estrategia la implementamos en la siguiente función, la cual depende de un <code class="docutils literal notranslate"><span class="pre">epsilon</span></code> que va a definir cuándo suspenderemos la búsqueda.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">seno_v2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot; Esta función calcula el seno del ángulo x utilizando la serie. </span>
<span class="sd">      Se utiliza el parámetro epsilon para definir la precisión de la respuesta.</span>
<span class="sd">  Parámetros:</span>
<span class="sd">    x (float): El ángulo en radianes para el que se quiere calcular el seno.</span>
<span class="sd">    epsilon (float): La precisión de la respuesta</span>
<span class="sd">  Retorno:</span>
<span class="sd">    (float): El seno del ángulo con una precisión de &#39;epsilon&#39;.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">suma_anterior</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">suma</span> <span class="o">-</span> <span class="n">suma_anterior</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">:</span>
    <span class="n">signo</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">mult</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">suma_anterior</span> <span class="o">=</span> <span class="n">suma</span>
    <span class="n">suma</span> <span class="o">+=</span> <span class="p">(</span><span class="n">signo</span><span class="o">*</span><span class="n">mult</span><span class="o">/</span><span class="n">denom</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="c1"># Se imprime la cantidad de iteraciones para saber cuántas son necesarias en cada caso</span>
  <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fueron&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;iteraciones&quot;</span><span class="p">)</span> 
  <span class="k">return</span> <span class="n">suma</span>

<span class="k">def</span> <span class="nf">probar2</span><span class="p">(</span><span class="n">angulo</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot; Invoca la función seno_v2 para calcular el seno del ángulo y compara el resultado</span>
<span class="sd">      con el resultado que arroja la función sin del módulo math.</span>
<span class="sd">      Se utiliza un valor para epsilon de 0.01</span>
<span class="sd">  Parámetros:</span>
<span class="sd">    angulo (float): El ángulo en radianes con el que se va a hacer la prueba  </span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">seno_v2</span><span class="p">(</span><span class="n">angulo</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
  <span class="n">real</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angulo</span><span class="p">)</span>
  <span class="n">error</span> <span class="o">=</span> <span class="n">res</span> <span class="o">-</span> <span class="n">real</span>
  <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ángulo:&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">angulo</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;Calculado:&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;Real:&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;Error:&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>La nueva versión de nuestra función seno ahora espera dos parámetros, <code class="docutils literal notranslate"><span class="pre">x</span></code> y <code class="docutils literal notranslate"><span class="pre">epsilon</span></code>, y no depende de un número de iteraciones fijo. En su lugar, la función mantiene todo el tiempo dos valores <code class="docutils literal notranslate"><span class="pre">suma</span></code> y <code class="docutils literal notranslate"><span class="pre">suma_anterior</span></code>: el primero representa el valor de la sumatoria hasta la iteración actual; el segundo representa el valor de la sumatoria hasta la iteración anterior. Mientras que la diferencia entre estos dos valores sea inferior a epsilon (<code class="docutils literal notranslate"><span class="pre">abs(suma</span> <span class="pre">-</span> <span class="pre">suma_anterior)</span> <span class="pre">&gt;</span> <span class="pre">epsilon</span></code>), el ciclo continuará ejecutándose.</p>
<p>La nueva función <code class="docutils literal notranslate"><span class="pre">probar2</span></code> es muy similar a la función <code class="docutils literal notranslate"><span class="pre">probar</span></code>: el único cambio es que ahora esta función llama a <code class="docutils literal notranslate"><span class="pre">seno_v2</span></code> y que además utiliza <code class="docutils literal notranslate"><span class="pre">0.01</span></code> como valor para el parámetro <code class="docutils literal notranslate"><span class="pre">epsilon</span></code>.</p>
<p>A continuación mostramos el resultado de probar nuestra nueva función con los primeros ángulos: 0, <span class="math notranslate nohighlight">\(\pi\)</span>/6, <span class="math notranslate nohighlight">\(\pi\)</span>/3, <span class="math notranslate nohighlight">\(\pi\)</span>/2 y <span class="math notranslate nohighlight">\(\pi\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Fueron</span> <span class="mi">1</span> <span class="n">iteraciones</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mi">0</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">0.0</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">0.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">0.0</span>
<span class="n">Fueron</span> <span class="mi">3</span> <span class="n">iteraciones</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">0.52</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">0.5</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">0.5</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">0.0</span>
<span class="n">Fueron</span> <span class="mi">4</span> <span class="n">iteraciones</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">1.05</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">0.87</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">0.87</span> <span class="n">Error</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.0</span>
<span class="n">Fueron</span> <span class="mi">4</span> <span class="n">iteraciones</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">1.57</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">1.0</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">1.0</span> <span class="n">Error</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.0002</span>
<span class="n">Fueron</span> <span class="mi">6</span> <span class="n">iteraciones</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">3.14</span> <span class="n">Calculado</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.0</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">0.0</span> <span class="n">Error</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.0004</span>
</pre></div>
</div>
<p>En este resultado podemos ver que que el error sigue siendo muy bajo. Podemos ver también que para los 4 primeros casos era suficiente con hacer 4 iteraciones para encontrar un resultado con un margen de error inferior al 0.01 (epsilon). A continuación mostramos el resultado de probar con los ángulos que antes nos causaron problemas: <span class="math notranslate nohighlight">\(\pi\)</span>*1.5, <span class="math notranslate nohighlight">\(\pi\)</span>*2, <span class="math notranslate nohighlight">\(\pi\)</span>*2.5, <span class="math notranslate nohighlight">\(\pi\)</span>*3 y <span class="math notranslate nohighlight">\(\pi\)</span>*4.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Fueron</span> <span class="mi">8</span> <span class="n">iteraciones</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">4.71</span> <span class="n">Calculado</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.0</span> <span class="n">Real</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.0</span> <span class="n">Error</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.0007</span>
<span class="n">Fueron</span> <span class="mi">11</span> <span class="n">iteraciones</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">6.28</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">0.0</span> <span class="n">Real</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">0.0001</span>
<span class="n">Fueron</span> <span class="mi">13</span> <span class="n">iteraciones</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">7.85</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">1.0</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">1.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">0.0001</span>
<span class="n">Fueron</span> <span class="mi">15</span> <span class="n">iteraciones</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">9.42</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">0.0</span> <span class="n">Real</span><span class="p">:</span> <span class="mf">0.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">0.0002</span>
<span class="n">Fueron</span> <span class="mi">19</span> <span class="n">iteraciones</span>
<span class="n">Ángulo</span><span class="p">:</span> <span class="mf">12.57</span> <span class="n">Calculado</span><span class="p">:</span> <span class="mf">0.0</span> <span class="n">Real</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.0</span> <span class="n">Error</span><span class="p">:</span> <span class="mf">0.0003</span>
</pre></div>
</div>
<p>En este caso vemos que fueron necesarias más iteraciones para llegar a una respuesta correcta. Pero también vemos que en todos los casos se logró llegar a una buena respuesta con una cantidad relativamente pequeña de iteraciones.</p>
</div>
</div>
<div class="section" id="for-in-range">
<h2>For-in-range<a class="headerlink" href="#for-in-range" title="Permalink to this headline">¶</a></h2>
<p>Motivación usando la sumatoria</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sumar_numeros</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
  <span class="n">sumatoria</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">sumatoria</span> <span class="o">+=</span> <span class="n">i</span>
  <span class="k">return</span> <span class="n">sumatoria</span>
</pre></div>
</div>
<p>explicación del range: inicio, fin (opcional), avance (opcional)</p>
<p>ejemplo: sumar sólo los pares</p>
</div>
<div class="section" id="ciclos-e-interfaces-basadas-en-consola">
<h2>Ciclos e interfaces basadas en consola<a class="headerlink" href="#ciclos-e-interfaces-basadas-en-consola" title="Permalink to this headline">¶</a></h2>
<p>el menú …</p>
</div>
<div class="section" id="ejercicios">
<h2>Ejercicios<a class="headerlink" href="#ejercicios" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Escriba la función llamada <code class="docutils literal notranslate"><span class="pre">imprimir_pares</span></code> que reciba dos enteros <code class="docutils literal notranslate"><span class="pre">a</span></code> y <code class="docutils literal notranslate"><span class="pre">b</span></code> e imprima todos los números enteros pares que se encuentran en el rango  [<code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>]. La función debe retornar la cantidad de números pares que se imprimieron.</p></li>
<li><p>Construya la función <code class="docutils literal notranslate"><span class="pre">potencia</span></code> que recibe una base y un exponente (entero positivo) y que retorna la base elevada al exponente. Su función debe implementarse usando ciclos, sin usar el operador <code class="docutils literal notranslate"><span class="pre">**</span></code> o la función <code class="docutils literal notranslate"><span class="pre">pow</span></code>. Compare el resultado de su función con el resultado de la función <code class="docutils literal notranslate"><span class="pre">pow</span></code>.</p></li>
<li><p>Escriba una función llamada <code class="docutils literal notranslate"><span class="pre">contar_divisores</span></code> que reciba tres enteros <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span></code> y <code class="docutils literal notranslate"><span class="pre">b</span></code>. La función debe retornar la cantidad de enteros en el rango [<code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>] que sean divisibles por el número <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p>Cuando estudiamos el centinela, escribimos un programa que lanza un dado virtual hasta encontrar un número determinado e informa la cantidad de intentos. Escriba una función llamada <code class="docutils literal notranslate"><span class="pre">buscar_numero_dos_dados</span></code> que reciba un número entre 2 y 12 y retorne la cantidad de veces que tuvo que lanzar dos dados virtuales para obtener el número.</p></li>
<li><p>Escriba una función llamada <code class="docutils literal notranslate"><span class="pre">probar_dados</span></code> que reciba un número entre 2 y 12 y también un número de iteraciones. La función tiene que llamar a la función <code class="docutils literal notranslate"><span class="pre">buscar_numero_dos_dados</span></code> la cantidad de veces especificada en el parámetro de las iteraciones. Al final, la función tiene que calcular la cantidad de veces promedio que se tuvieron que lanzar los datos para obtener el número especificado. Por ejemplo, para los números 2 y 12 se esperaría que el número de lanzamientos requeridos estuviera cerca a 36 cuando el número de iteraciones sea relativamente grande (más de 1000).</p></li>
<li><p>Escriba la función <code class="docutils literal notranslate"><span class="pre">es_primo</span></code> que recibe un número entero positivo mayor a 1 y retorna un valor booleano indicando si el número es primo o no. Recuerde que un número primo sólo es divisible por él y por 1.</p></li>
<li><p>Escriba la función <code class="docutils literal notranslate"><span class="pre">contar_primos</span></code> que reciba dos números <code class="docutils literal notranslate"><span class="pre">a</span></code> y <code class="docutils literal notranslate"><span class="pre">b</span></code> y retorne la cantidad de números primos que haya dentro del intervalo [a, b]. Es decir que <code class="docutils literal notranslate"><span class="pre">contar_primos(2,</span> <span class="pre">13)</span></code> debería retornar 6 porque ese es el número de primos entre 2 y 13 (los primos en el rango son 2, 3, 5, 7, 11 y 13).</p></li>
<li><p>Escriba la función <code class="docutils literal notranslate"><span class="pre">sumar_digitos</span></code> que reciba un número entero y retorne la suma de sus dígitos. Por ejemplo, si el número entero es 123, la función debería retornar 6.</p></li>
<li><p>Escriba la función <code class="docutils literal notranslate"><span class="pre">hay_un_7</span></code> que reciba un número entero y retorne un booleano indicando si alguno de los dígitos el número es un 7.</p></li>
<li><p>La conjetura de Collatz dice que si se aplica repetidamente la función <code class="docutils literal notranslate"><span class="pre">f</span></code> (definida a continuación) siempre se va a llegar al valor 1.</p></li>
</ol>
<p>\begin{equation}
f(n) =
\begin{cases}
n/2,  &amp; \text{si <span class="math notranslate nohighlight">\(n\)</span> es par} \
3n+1, &amp; \text{si <span class="math notranslate nohighlight">\(n\)</span> es impar}
\end{cases}
\end{equation}</p>
<p>Implemente la función <code class="docutils literal notranslate"><span class="pre">collatz</span></code> que dado un entero <code class="docutils literal notranslate"><span class="pre">n</span></code> retorne la cantidad de veces que se debe aplicar la función <code class="docutils literal notranslate"><span class="pre">f</span></code> para llegar a 1. Es decir, <code class="docutils literal notranslate"><span class="pre">collatz(1)</span></code> debería ser 0 porque no es necesario llamar la función <code class="docutils literal notranslate"><span class="pre">f</span></code>; <code class="docutils literal notranslate"><span class="pre">collatz(2)</span></code> debería ser 1 porque sólo se debe llamar una vez la función (<code class="docutils literal notranslate"><span class="pre">1==f(2)</span></code>); y <code class="docutils literal notranslate"><span class="pre">collatz(3)</span></code> debería ser 7 (<code class="docutils literal notranslate"><span class="pre">1==f(f(f(f(f(f(f(3)))))))</span></code>).</p>
</div>
<div class="section" id="mas-alla-de-python">
<h2>Más allá de Python<a class="headerlink" href="#mas-alla-de-python" title="Permalink to this headline">¶</a></h2>
<p>La instrucción <code class="docutils literal notranslate"><span class="pre">while</span></code> en Python es similar a la instrucción <code class="docutils literal notranslate"><span class="pre">while</span></code> en lenguajes como C, C++, Java y muchos otros. Sin embargo, en lenguajes descendientes de C también existe la instrucción <code class="docutils literal notranslate"><span class="pre">for</span></code> que es completamente equivalente a un <code class="docutils literal notranslate"><span class="pre">while</span></code>. Esto no es cierto para el caso de Python porque la instrucción <code class="docutils literal notranslate"><span class="pre">for</span></code> es mucho más similar a lo que sería un <code class="docutils literal notranslate"><span class="pre">for-each</span></code> en Java y otros lenguajes. Esto lo estudiaremos con más detalle en la sección sobre <em>Recorrido de secuencias</em>. Por ahora lo que usted debe saber es que un <code class="docutils literal notranslate"><span class="pre">for</span></code> escrito en un lenguaje como los mencionados probablemente tendrá que convertirse en un <code class="docutils literal notranslate"><span class="pre">while</span></code> si un programa se traduce a Python.</p>
<p>En muchos cursos y libros el estudio de ciclos se mezcla o se reemplaza por el estudio de la recursión. En lenguajes funcionales, como Lisp, Scheme o Haskell, es más natural escribir funciones recursivas que escribir ciclos como los que hemos estudiado en esta sección. En lenguajes como C o Java, es practicamente equivalente escribir ciclos que funciones recursivas, aunque la recursión podría tener problemas de desempeño en algunos casos. En este curso no vamos estudiar el tema de recursión, aunque que Python soporta sin ningún problema. A manera de ejemplo, presentamos la versión recursiva de la función que calcula el factorial de un número.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">factorial_v6</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial_v6</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li></li>
</ul>
<hr class="docutils" />
<dl class="footnote brackets">
<dt class="label" id="introalgo"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Esta es sólo una introducción a la problemática. A medida que avancemos en la presentación de las instrucciones iterativas iremos profundizando en la discusión.</p>
</dd>
<dt class="label" id="respuestas"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Las soluciones son: 1: a, 2: u, 3: a, 4: u, 5: e, 6: u., 7: a.</p>
</dd>
<dt class="label" id="demorgan"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>No olvide los teoremas de De Morgan:  <strong><span class="math notranslate nohighlight">\(\lnot\)</span> (P <span class="math notranslate nohighlight">\(\land\)</span> Q) <span class="math notranslate nohighlight">\(\equiv\)</span> <span class="math notranslate nohighlight">\(\lnot\)</span> P <span class="math notranslate nohighlight">\(\lor\)</span> <span class="math notranslate nohighlight">\(\lnot\)</span> Q</strong> y <strong><span class="math notranslate nohighlight">\(\lnot\)</span> (P <span class="math notranslate nohighlight">\(\lor\)</span> Q) <span class="math notranslate nohighlight">\(\equiv\)</span> <span class="math notranslate nohighlight">\(\lnot\)</span> P <span class="math notranslate nohighlight">\(\land\)</span> <span class="math notranslate nohighlight">\(\lnot\)</span> Q</strong></p>
</dd>
</dl>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./nivel3"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Mario Sánchez<br/>
        
            &copy; Copyright Agosto de 2020.<br/>
          <div class="extra_footer">
            <a href="http://sistemas.uniandes.edu.co">Departamento de Ingeniería de Sistemas y Computación</a> - Universidad de los Andes
          </div>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>